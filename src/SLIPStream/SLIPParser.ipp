#include "SLIPParser.hpp"

template <class Callback>
size_t SLIPParser::parse(uint8_t c, Callback callback) {
    using namespace SLIP_Constants;
    /*
     * handle bytestuffing if necessary
     */
    switch (c) {
        /*
         * if it's an END character then we're done with
         * the packet
         */
        case END: {
            /* 
             * a minor optimization: if there is no
             * data in the packet, ignore it. This is
             * meant to avoid bothering IP with all
             * the empty packets generated by the
             * duplicate END characters which are in
             * turn sent to try to detect line noise.
             */
            auto packetLen = write - buffer;
            escape         = false;
            reset();
            if (packetLen)
                return packetLen;
        } break;

        /*
         * if it's the same code as an ESC character, wait
         * and get another character and then figure out
         * what to store in the packet based on that.
         */
        case ESC: {
            escape = true;
        } break;

        /*
         * here we fall into the default handler and let
         * it store the character for us
         */
        default: {
            if (escape) {
                /*
                 * if "c" is not one of these two, then we
                 * have a protocol violation.  The best bet
                 * seems to be to leave the byte alone and
                 * just stuff it into the packet
                 */
                switch (c) {
                    case ESC_END: c = END; break;
                    case ESC_ESC: c = ESC; break;
                    default: break; // LCOV_EXCL_LINE
                }
                escape = false;
            }
            auto writeSize = reinterpret_cast<uintptr_t>(write) -
                             reinterpret_cast<uintptr_t>(buffer);
            callback(c, writeSize);
            if (writeSize < bufferSize) {
                if (writeSize == 0) // first byte of packet
                    truncated = false;
                *write++ = c;
            } else {
                truncated = true;
            }
        }
    }
    return 0;
}