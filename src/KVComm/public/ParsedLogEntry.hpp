#pragma once

#ifndef ARDUINO

#include <KVComm/public/LoggerTypes.hpp>  // LoggableType

#include <cstdint>    // uint8_t, uint32_t
#include <map>        // std::map
#include <stdexcept>  // std::logic_error, std::out_of_range, std::length_error
#include <string>     // std::string
#include <vector>     // std::vector

/// @addtogroup logger
/// @{

/**
 * @file  
 * @brief   A parser for log entries generated by the Logger (intended to run
 *          on your computer or on the Zybo Linux core, not on the Baremetal 
 *          core).
 */

/// Class for parsing a LogEntry from a buffer of bytes
class ParsedLogEntry {
  private:
    /// Functor to compare the map keys
    struct strcmp {
        bool operator()(const char *a, const char *b) const;
    };
    using KV    = LogEntryIterator::KV;
    using map_t = std::map<const char *, KV, strcmp>;

    map_t parseResult{};

  public:
    /**
     * @brief   Parse a raw buffer into a new ParsedLogEntry.
     * 
     * @param   buffer
     *          A pointer to the raw buffer containing the LogEntry.
     *          Only the pointer is saved, no copy is made of the actual buffer,
     *          so the lifetime of the buffer must be longer than the parser and
     *          the LogElement accessors.
     * @param   length
     *          The length of the LogEntry in the buffer (in bytes).
     */
    ParsedLogEntry(const uint8_t *buffer, size_t length)
        : parseResult{parse(buffer, length)} {}

    /**
     * @brief   Check if the LogEntry contains an element with the given 
     *          identifier/key.
     * 
     * @param   key
     *          The identifier of the element to check. 
     * @return  true if the LogEntry contains an element with the given 
     *          identifier, false if it doesn't.
     */
    bool contains(const char *key) const {
        return parseResult.find(key) != parseResult.end();
    }

    /**
     * @brief   Get the element with the given identifier/key.
     * 
     * @param   key 
     *          The identifier of the element to retreive.
     * @return  The element with the given identifier.
     * @throw   std::out_of_range
     *          There is no element with the given identifier.
     */
    KV getElement(const char *key) const { return parseResult.at(key); }
    /// @copydoc getElement
    KV operator[](const char *key) const { return getElement(key); }
    /// Begin iterator over all LogElements in the LogEntry
    map_t::iterator begin() { return parseResult.begin(); }
    /// Begin iterator over all LogElements in the LogEntry
    map_t::const_iterator begin() const { return parseResult.begin(); }
    /// End iterator over all LogElements in the LogEntry
    map_t::iterator end() { return parseResult.end(); }
    /// End iterator over all LogElements in the LogEntry
    map_t::const_iterator end() const { return parseResult.end(); }

  private:
    /**
     * @brief   Parse the buffer for LogElements, save their identifiers, type,
     *          and size in an std::map, together with a pointer to the actual
     *          data. 
     * 
     * @param   buffer 
     *          A pointer to the raw buffer containing the LogEntry.
     * @param   length 
     *          The length of the LogEntry in the buffer (in bytes).
     * @return  A map mapping the identifiers to the LogElements.
     */
    map_t parse(const uint8_t *buffer, size_t length);
};

/// @}

#endif  // ARDUINO