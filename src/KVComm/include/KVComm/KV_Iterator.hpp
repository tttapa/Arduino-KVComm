#pragma once

#ifdef ARDUINO

#include <KVComm/include/KVComm/KV_Error.hpp> // KV_ERROR
#include <KVComm/include/KVComm/KV_Helpers.hpp> // nextWord, roundUpToWordSizeMultiple
#include <KVComm/include/KVComm/KV_Types.hpp> // KV_Type<T>

#include <AH/STL/array>    // std::array
#include <AH/STL/cstddef>  // size_t
#include <AH/STL/cstdint>  // uint8_t, uint16_t
#include <AH/STL/iterator> // iterator traits
#include <AH/STL/vector>   // std::vector

#include <WString.h>

#else

#include <KVComm/KV_Error.hpp>   // KV_ERROR
#include <KVComm/KV_Helpers.hpp> // nextWord, roundUpToWordSizeMultiple
#include <KVComm/KV_Types.hpp>   // KV_Type<T>

#include <array>    // std::array
#include <cstddef>  // size_t
#include <cstdint>  // uint8_t, uint16_t
#include <iterator> // iterator traits
#include <vector>   // std::vector

#endif

/// @addtogroup KVComm
/// @{

/**
 * @file  
 * @brief   Iterating over a dictionary generated by the KV_Builder, used for 
 *          parsing and for checking if a key is already in the entry.
 */

/// Class for iterating over a dictionary generated by the KV_Builder, used for
/// parsing and for checking if a key is already in the entry.
class KV_Iterator {
  public:
    KV_Iterator(const uint8_t *buffer, size_t length)
        : buffer(buffer), bufferSize(length) {}

    class KV {
      public:
        /// Constructor
        KV(const uint8_t *buffer) : buffer(buffer) {}
        /// Get the type ID of the current element.
        uint8_t getTypeID() const { return buffer[1]; }
        /// Get the length of the identifier / key of the current element.
        uint16_t getIDLength() const { return buffer[0]; }
        /// Get the length of the data of the current element.
        uint16_t getDataLength() const {
            return (buffer[2] << 0) | (buffer[3] << 8);
        }
        /// Get a pointer to the beginning of the current element.
        const uint8_t *getBuffer() const { return buffer; }
        /// Get the identifier / key of the current element.
        const char *getID() const { return (const char *) buffer + 4; }
        /// Get a pointer to the data of the current element.
        const uint8_t *getData() const {
            return buffer + nextWord(getIDLength()) + 4;
        }
        /// Check if the key-value pair is valid.
        explicit operator bool() const { return buffer != nullptr; }

        /**
         * @brief   Get the data as the given type.
         * 
         * @tparam  T
         *          The type of value to read.
         * @param[out]  t
         *          The value is read from the dictionary into this variable.
         * @param[in]   index
         *          The index of the element of the array to read (if the value 
         *          is an array).
         * 
         * @throw   0x7566
         *          Trying to extract data from non-existent entry.
         * @throw   0x7563
         *          Type mismatch: The dynamic type ID doesn't match the type ID
         *          of `T`.
         * @throw   0x7564
         *          Index out of range.
         */
        template <class T>
        void get(T &t, size_t index = 0) const {
            if (!*this) {
                KV_ERROR(F("Trying to extract data from non-existent entry"),
                         0x7566);
                return; // LCOV_EXCL_LINE
            }
            if (!checkType<T>())
                return; // LCOV_EXCL_LINE
            if (index * KV_Type<T>::getLength() >= getDataLength()) {
                KV_ERROR(F("Index out of range"), 0x7564);
                return; // LCOV_EXCL_LINE
            }
            auto readlocation = getData() + KV_Type<T>::getLength() * index;
            KV_Type<T>::readFromBuffer(t, readlocation);
        }

        /**
         * @brief   Get the data as the given type.
         * 
         * @tparam  T
         *          The type of value to read.
         * @param   index
         *          The index of the element of the array to read (if the value 
         *          is an array).
         * @return  The requested element of the value from this key-value pair,
         *          casted to the given type `T`.
         * 
         * @throw   0x7566
         *          Trying to extract data from non-existent entry.
         * @throw   0x7563
         *          Type mismatch: The dynamic type ID doesn't match the type ID
         *          of `T`.
         * @throw   0x7564
         *          Index out of range.
         */
        template <class T>
        T getAs(size_t index = 0) const {
            T t;
            get(t, index);
            return t;
        }

        /**
         * @brief   Get the data of the element as a vector of the given type.
         * 
         * @tparam  T 
         *          The type of the data. This must be the same as the dynamic
         *          type of the data.
         * @return  A vector containing the data of the element, converted to 
         *          the correct type.
         * 
         * @throw   0x7566
         *          Trying to extract data from non-existent entry.
         * @throw   0x7563
         *          Type mismatch: The dynamic type ID doesn't match the type ID
         *          of `T`.
         */
        template <class T>
        std::vector<T> getVector() const {
            if (!*this) {
                KV_ERROR(F("Trying to extract data from non-existent entry"),
                         0x7566);
                return {}; // LCOV_EXCL_LINE
            }
            if (!checkType<T>())
                return {}; // LCOV_EXCL_LINE
            size_t size = getDataLength() / KV_Type<T>::getLength();
            std::vector<T> result(size);
            auto readlocation = getData();
            for (T &t : result) {
                KV_Type<T>::readFromBuffer(t, readlocation);
                readlocation += KV_Type<T>::getLength();
            }
            return result;
        }

        /**
         * @brief   Get the data of the element as an array of the given type.
         * 
         * @tparam  T 
         *          The type of the data. This must be the same as the dynamic
         *          type of the data.
         * @tparam  N
         *          The number of elements in the array. This must be the same
         *          as the length of the data.
         * @return  An array containing the data of the element, converted to 
         *          the correct type.
         * @throw   0x7566
         *          Trying to extract data from non-existent entry.
         * @throw   0x7563
         *          Type mismatch: The dynamic type ID doesn't match the type ID
         *          of `T`.
         * @throw   0x7565
         *          Incorrect length: The specified array size `N` doesn't match
         *          the actual dynamic size of the element.
         */
        template <class T, size_t N>
        std::array<T, N> getArray() const {
            if (!*this) {
                KV_ERROR(F("Trying to extract data from non-existent entry"),
                         0x7566);
                return {{}}; // LCOV_EXCL_LINE
            }
            if (!checkType<T>())
                return {{}}; // LCOV_EXCL_LINE
            if (N * KV_Type<T>::getLength() != getDataLength()) {
                KV_ERROR(F("Incorrect length"), 0x7565);
                return {{}}; // LCOV_EXCL_LINE
            }
            std::array<T, N> result;
            auto readlocation = getData();
            for (T &t : result) {
                KV_Type<T>::readFromBuffer(t, readlocation);
                readlocation += KV_Type<T>::getLength();
            }
            return result;
        }

#if !defined(ARDUINO) || defined(DOXYGEN)
        /**
         * @brief   Get the character array as an std::string.
         * 
         * @return  The character array as a string.
         * 
         * @note    Returns an Arduino `String` instead of an `std::string` on 
         *          Arduino.
         * 
         * @throw   0x7566
         *          Trying to extract data from non-existent entry.
         * @throw   0x7563
         *          Type mismatch: The dynamic type ID doesn't match the type ID
         *          of `char`.
         */
        std::string getString() const;
#else
        String getString() const;
#endif

        /**
         * @brief   Check if the type of this element is the same as the given 
         *          type.
         * 
         * @tparam  T
         *          The type to compare to the type of this element.
         * @retval  true
         *          The types are the same.
         * @retval  false
         *          Otherwise.
         */
        template <class T>
        bool hasType() const {
            return this->getTypeID() == KV_Type<T>::getTypeID();
        }

      private:
        /// Assert that the type of this entry matches the given type `T`.
        template <class T>
        bool checkType() const {
            if (!hasType<T>()) {
                KV_ERROR(F("Type mismatch (typeid=")
                             << getTypeID() << F(", conversion requested to ")
                             << KV_Type<T>::getTypeID() << ')',
                         0x7563);
                return false; // LCOV_EXCL_LINE
            }
            return true;
        }

      private:
        const uint8_t *buffer;
    };

    class iterator {
      public:
        /// Default constructor. Used as "end" iterator (sentinel).
        iterator();
        /// Create KV_Iterator that iterates over the elements in the
        /// buffer.
        /// Only the pointer is saved, the buffer itself is not copied over, so
        /// its lifetime must be longer than all iterators that point to it.
        iterator(const uint8_t *buffer, size_t length);

        /// Advance the iterator.
        iterator &operator++();
#if 0
        /// Compare the iterator to the "end" iterator. (Only compares the
        /// buffer pointer, which is nullptr for the "end" iterator.)
        bool operator==(const iterator &other) const;
#endif
        /// Compare the iterator to the "end" iterator. (Only compares the
        /// buffer pointer, which is nullptr for the "end" iterator.)
        bool operator!=(const iterator &other) const;

        const KV &operator*() const { return kv; }
        const KV *operator->() const { return &kv; }

        /// Check if the iterator is valid.
        explicit operator bool() const { return !!kv; }

        using difference_type   = void;
        using value_type        = KV;
        using pointer           = KV *;
        using reference         = KV &;
        using iterator_category = std::input_iterator_tag;

      private:
        void checkLength();

      private:
        KV kv;
        size_t remainingBufferLength;
    };

    /// Iterator to the first key-value entry of the dictionary.
    iterator begin() const { return {buffer, bufferSize}; }
    /// End/sentinel iterator.
    static iterator end() { return {}; }

    /// Find the entry with the given key (iterates over entire dictionary).
    iterator find(const char *key) const;

  private:
    const uint8_t *buffer;
    size_t bufferSize;
};

/// @}