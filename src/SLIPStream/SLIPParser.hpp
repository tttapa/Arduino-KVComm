#pragma once

#include <AH/STL/utility> // std::forward
#include <stddef.h>       // size_t

#include <SLIPStream/SLIP.hpp>

#include <boost/integer.hpp>

class SLIPParser {
  public:
    SLIPParser(uint8_t *buffer, size_t bufferSize)
        : buffer(buffer), bufferSize(bufferSize) {
        reset();
    }

    template <class Callback>
    size_t parse(uint8_t c, Callback callback) {
        using namespace SLIP_Constants;
        /*
         * handle bytestuffing if necessary
         */
        switch (c) {
            /*
             * if it's an END character then we're done with
             * the packet
             */
            case END: {
                /* 
                 * a minor optimization: if there is no
                 * data in the packet, ignore it. This is
                 * meant to avoid bothering IP with all
                 * the empty packets generated by the
                 * duplicate END characters which are in
                 * turn sent to try to detect line noise.
                 */
                auto packetLen = write - buffer;
                escape         = false;
                reset();
                if (packetLen)
                    return packetLen;
            } break;

            /*
             * if it's the same code as an ESC character, wait
             * and get another character and then figure out
             * what to store in the packet based on that.
             */
            case ESC: {
                escape = true;
            } break;

            /*
             * here we fall into the default handler and let
             * it store the character for us
             */
            default: {
                if (escape) {
                    /*
                     * if "c" is not one of these two, then we
                     * have a protocol violation.  The best bet
                     * seems to be to leave the byte alone and
                     * just stuff it into the packet
                     */
                    switch (c) {
                        case ESC_END: c = END; break;
                        case ESC_ESC: c = ESC; break;
                        default: {}
                    }
                    escape = false;
                }
                callback(c);
                if (reinterpret_cast<uintptr_t>(write) -
                        reinterpret_cast<uintptr_t>(buffer) <
                    bufferSize) {
                    if (write == buffer)
                        truncated = false;
                    *write++ = c;
                } else {
                    truncated = true;
                }
            }
        }
        return 0;
    }

    size_t parse(uint8_t c) {
        auto cb = [](uint8_t) {};
        return parse(c, cb);
    }

    bool wasTruncated() const { return truncated; }

  private:
    void reset() { write = buffer; }

  private:
    uint8_t *buffer   = nullptr;
    uint8_t *write    = nullptr;
    size_t bufferSize = 0;
    bool truncated    = false;
    bool escape       = false;
};

template <class CRC>
class SLIPParserCRC {
  public:
    SLIPParserCRC() = default;
    SLIPParserCRC(const SLIPParser &parser, CRC &&crc)
        : parser(parser), crc(std::forward<CRC>(crc)) {}

    using checksum_t = typename boost::uint_t<CRC::bit_count>::least;

    size_t parse(uint8_t c) {
        size_t size = parser.parse<CRC &>(c, crc);
        return size < sizeof(checksum_t) ? 0 : size - sizeof(checksum_t);
    }

    bool wasTruncated() const { return parser.wasTruncated(); }
    auto checksum() const { return crc.checksum(); }

  private:
    SLIPParser parser;
    CRC crc;
};

// #include "SLIPParser.ipp"
